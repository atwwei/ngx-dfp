{"version":3,"file":"parse-duration.service.js","sourceRoot":"","sources":["../../src/service/parse-duration.service.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,sCAA2C;AAE3C;IAA+B,oCAAK;IAClC,0BAAY,QAAQ;eAClB,kBAAM,wBAAsB,QAAQ,QAAK,CAAC;IAC5C,CAAC;IACH,uBAAC;AAAD,CAAC,AAJD,CAA+B,KAAK,GAInC;AAED;IAAA;IA4CA,CAAC;IAzCC,oDAAqB,GAArB,UAAsB,IAAI,EAAE,IAAI;QAC9B,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAE5C,EAAE,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAAC,CAAC;QACnC,EAAE,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;QAAC,CAAC;QACzC,EAAE,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC;QAAC,CAAC;QAEhD,MAAM,CAAC,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;IAC/B,CAAC;IAED,sCAAO,GAAP,UAAQ,KAAK;QACX,IAAM,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAElC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAAC,CAAC;QAExC,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpD,CAAC;IAED,4CAAa,GAAb,UAAc,QAAQ;QAEpB,EAAE,CAAC,CAAC,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC;YAChD,MAAM,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACvC,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC;YACjC,MAAM,CAAC,QAAQ,CAAC;QAClB,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC;YACjC,MAAM,IAAI,SAAS,CAAC,MAAI,QAAQ,uCAAoC,CAAC,CAAC;QACxE,CAAC;QAED,IAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;QAE5D,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACvC,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;;gBA1CF,iBAAU;;IA4CX,2BAAC;CAAA,AA5CD,IA4CC;AA3CY,oDAAoB","sourcesContent":["import { Injectable } from '@angular/core';\n\nclass DFPDurationError extends Error {\n  constructor(interval) {\n    super(`Invalid interval: '${interval}'ls`);\n  }\n}\n\n@Injectable()\nexport class ParseDurationService {\n\n  convertToMilliseconds(time, unit) {\n    console.assert(/^(m?s|min|h)$/g.test(unit));\n\n    if (unit === 'ms') { return time; }\n    if (unit === 's') { return time * 1000; }\n    if (unit === 'min') { return time * 60 * 1000; }\n\n    return time * 60 * 60 * 1000;\n  }\n\n  convert(match) {\n    const time = parseFloat(match[1]);\n\n    if (match.length === 2) { return time; }\n\n    return this.convertToMilliseconds(time, match[2]);\n  }\n\n  parseDuration(interval) {\n\n    if (interval === undefined || interval === null) {\n      throw new DFPDurationError(interval);\n    }\n\n    if (typeof interval === 'number') {\n      return interval;\n    }\n\n    if (typeof interval !== 'string') {\n      throw new TypeError(`'${interval}' must be of number or string type`);\n    }\n\n    const match = interval.match(/((?:\\d+)?.?\\d+)(m?s|min|h)?/);\n\n    if (!match) {\n      throw new DFPDurationError(interval);\n    }\n\n    return this.convert(match);\n  }\n\n}\n"]}